{{ define "script" }}
<script>
    // Set PDF.js workerSrc
    pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    let currentPage = 0;
    let loading = false;
    let hasMore = true;

    async function renderPDF(url, container, zoomLevel = 1) {
        try {
            const loadingTask = pdfjsLib.getDocument(url);
            const pdf = await loadingTask.promise;

            // Get the first page (assuming a single-page PDF for this example)
            const page = await pdf.getPage(1);

            // Calculate desired width and height
            const viewport = page.getViewport({ scale: 1 });
            const containerWidth = container.clientWidth;
            const scale = Math.max(1, (containerWidth / viewport.width) * zoomLevel);
            const scaledViewport = page.getViewport({ scale });

            // Create canvas and context
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.width = scaledViewport.width;
            canvas.height = scaledViewport.height;

            // Create wrapper for canvas
            const canvasWrapper = document.createElement("div");
            canvasWrapper.className = "canvas-container";
            canvasWrapper.appendChild(canvas);
            container.appendChild(canvasWrapper);

            // Render PDF page
            await page.render({
                canvasContext: context,
                viewport: scaledViewport,
            }).promise;
        } catch (error) {
            console.error("Error rendering PDF:", error);
            container.innerHTML =
                '<p style="color: red; text-align: center;">Error loading PDF</p>';
        }
    }

    async function loadBatchPages(batchSize = 5) {
        if (loading || !hasMore) return;

        loading = true;
        document.getElementById("loading").style.display = "block";

        try {
            for (let i = 0; i < batchSize; i++) {
                const response = await fetch(`/api/pages?page=${currentPage}`);
                if (response.status === 204) {
                    hasMore = false;
                    break;
                }

                const pages = await response.json();

                for (const page of pages) {
                    const pageDiv = document.createElement("div");
                    pageDiv.className = "pdf-page";
                    pageDiv.dataset.pdfPath = page.path;
                    document.getElementById("pdfContainer").appendChild(pageDiv);

                    // Lazy-load PDF rendering
                    observer.observe(pageDiv);
                }

                currentPage++;
            }
        } catch (error) {
            console.error("Error loading pages:", error);
        } finally {
            loading = false;
            document.getElementById("loading").style.display = "none";
        }
    }

    // Scroll detection with debounce
    function isNearBottom() {
        const scrollBuffer = 300; // Adjust buffer for triggering load
        return (
            window.innerHeight + window.scrollY >=
            document.body.offsetHeight - scrollBuffer
        );
    }

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Lazy loading using Intersection Observer
    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                const pageDiv = entry.target;
                renderPDF(pageDiv.dataset.pdfPath, pageDiv);
                observer.unobserve(pageDiv);
            }
        });
    });

    // Initial load
    loadBatchPages();

    // Infinite scroll with debounce
    window.addEventListener(
        "scroll",
        debounce(() => {
            if (isNearBottom()) {
                loadBatchPages();
            }
        }, 100),
    );

    // Resize handler without reload
    window.addEventListener(
        "resize",
        debounce(() => {
            const pdfPages = document.querySelectorAll(".pdf-page");
            pdfPages.forEach((pageDiv) => {
                const canvas = pageDiv.querySelector("canvas");
                if (canvas) {
                    const containerWidth = pageDiv.clientWidth;
                    const viewport = pageDiv.viewport;
                    const scale = containerWidth / viewport.width;
                    const scaledViewport = viewport.clone({ scale });

                    // Re-render the canvas
                    const context = canvas.getContext("2d");
                    canvas.width = scaledViewport.width;
                    canvas.height = scaledViewport.height;
                    page.render({
                        canvasContext: context,
                        viewport: scaledViewport,
                    }).promise;
                }
            });
        }, 250),
    );
</script>
{{ end }}
